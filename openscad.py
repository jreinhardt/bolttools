# Copyright 2012-2013 Johannes Reinhardt <jreinhardt@ist-dein-freund.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from os import listdir,makedirs
from os.path import join, exists, basename
from shutil import rmtree,copy
import yaml

class BaseModule:
	def __init__(self,mod,filename):
		self.name = mod["name"]
		self.filename = filename
		self.arguments = mod["arguments"]

class OpenSCADData:
	def __init__(self,path):
		#maps class id to base module
		self.getbase = {}

		self.basefilenames = []

		self.backend_root = join(path,"openscad")

		for coll in listdir(self.backend_root):
			basename = join(self.backend_root,coll,"%s.base" % coll)
			if not exists(basename):
				#skip directory that is no collection
				continue
			base =  list(yaml.load_all(open(basename)))
			if len(base) != 1:
				raise MalformedCollectionError(
						"No YAML document found in file %s" % bltname)
			base = base[0]
			for basefile in base:
				self.basefilenames.append(join(self.backend_root,coll,basefile["filename"]))
				if basefile["type"] == "module":
					for mod in basefile["modules"]:
						module = BaseModule(mod,basefile)
						for id in mod["ids"]:
							if id in self.getbase:
								raise NonUniqueClassIdentifier
							self.getbase[id] = module

class OpenSCADExporter:
	def write_output(self,repo):
		oscad = repo.openscad
		out_path = join(repo.path,"output","openscad")

		#clear output and copy files
		rmtree(out_path,True)

		makedirs(out_path)
		bolts_fid = open(join(out_path,"BOLTS.scad"),"w")
		standard_fids = {}
		for std in repo.standard_bodies:
			standard_fids[std] = open(join(out_path,"BOLTS_%s.scad" % std),"w")

		makedirs(join(out_path,"tables"))

		makedirs(join(out_path,"common"))
		for filename in listdir(join(oscad.backend_root,"common")):
			copy(join(oscad.backend_root,"common",filename),join(out_path,"common",filename))
			bolts_fid.write("include <common/%s>\n" % filename)
			for std in standard_fids:
				standard_fids[std].write("include <common/%s>\n" % filename)

		makedirs(join(out_path,"base"))
		for filename in oscad.basefilenames:
			copy(filename,join(out_path,"base"))
			bolts_fid.write("include <base/%s>\n" % basename(filename))
			for std in standard_fids:
				standard_fids[std].write("include <base/%s>\n" % basename(filename))

		#write tables
		for collection in repo.collections:
			for cl in collection.classes:
				if not cl.id in repo.openscad.getbase:
					continue
				table_path = join("tables","%s_table.scad" % cl.name)
				table_filename = join(out_path,table_path)
				fid = open(table_filename,"w")
				self.write_table(fid,collection,cl)
				fid.close()

				bolts_fid.write("include <%s>\n" % table_path)
				for std in standard_fids:
					if cl in repo.standardized[std]:
						standard_fids[std].write("include <%s>\n" % table_path)
		bolts_fid.write("\n\n")

		#write stubs
		for collection in repo.collections:
			for cl in collection.classes:
				if not cl.id in repo.openscad.getbase:
					continue
				self.write_stub(repo,bolts_fid,cl)
				for std in standard_fids:
					if cl in repo.standardized[std]:
						self.write_stub(repo,standard_fids[std],cl)
		bolts_fid.close()
		for std in standard_fids:
			standard_fids[std].close()

	def write_table(self,fid,collection,cl):
		for table,i in zip(cl.parameters.tables,range(len(cl.parameters.tables))):
			cols = table.columns
			fid.write("/* Generated by BOLTS, do not modify */\n")
			fid.write("/* Copyright by: %s */\n" % ",".join(collection.authors))
			fid.write("/* %s */\n" % collection.license)

			data = table.data

			fid.write("function %s_table_%d(key) = \n" % (cl.name,i))
			for k,values in data.iteritems():
				data = ["None" if v is None else v for v in values]
				fid.write('key == "%s" ? %s : \n' % (k,str(data).replace("'",'"')))
			fid.write('"Error";\n\n')

	def write_stub(self,repo,fid,cl):
		#collect textual parameter representations
		args = {}
		if not cl.standard is None:
			args['standard'] = '"%s"' % cl.name
		params = cl.parameters
		for p in params.free:
			args[p] = p
		args.update(params.literal)
		for table,i in zip(params.tables,range(len(params.tables))):
			for p,j in zip(table.columns,range(len(table.columns))):
				args[p] = 'measures_%d[%d]' % (i,j)

		fid.write('module %s(%s){\n' % (cl.name, ', '.join(cl.parameters.free)))
	
		for table,i in zip(cl.parameters.tables,range(len(cl.parameters.tables))):
			fid.write('\tmeasures_%d = %s_table_%d(%s);\n' % (i,cl.name,i,table.index))
			fid.write('\tif(measures_%d == "Error"){\n' % i)
			fid.write('\t\techo("TableLookUpError in %s, table %d");\n\t}\n' % (cl.name,i))

		fid.write('\tif(BOLTS_MODE == "bom"){\n')

		#write part name output for bom
		argc = 0
		fid.write('\t\techo(str(" "')
		for token in cl.naming.template.split():
			if token[0] == "%":
				fid.write(",")
				fid.write(args[cl.naming.substitute[argc]])
				fid.write('," "')
				argc += 1
			else:
				fid.write(',"%s"' % token)
				fid.write('," "')
		fid.write("));\n")
		#To avoid problems with missing top level object
		fid.write("\t\tcube();\n")

		fid.write("\t} else {\n")

		#module call
		base = repo.openscad.getbase[cl.id]
		fid.write('\t\t%s(%s);\n\t}\n}\n\n' % 
				(base.name,',\n\t\t\t'.join(args[arg] for arg in base.arguments)))

