# Copyright 2012-2013 Johannes Reinhardt <jreinhardt@ist-dein-freund.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from os import listdir,makedirs
from os.path import join, exists, basename
from shutil import rmtree,copy
import blt_parser
import yaml

class BaseModule:
	def __init__(self,mod,filename):
		self.name = mod["name"]
		self.filename = filename
		self.arguments = mod["arguments"]

class OpenSCADBackend:
	def __init__(self,path):

		#get application independent data
		self.repo = blt_parser.BOLTSRepository(path)

		#maps class id to base module
		self.getbase = {}

		self.basefilenames = []

		self.backend_root = join(path,"openscad")

		for coll in listdir(self.backend_root):
			basename = join(self.backend_root,coll,"%s.base" % coll)
			if not exists(basename):
				#skip directory that is no collection
				continue
			base =  list(yaml.load_all(open(basename)))
			if len(base) != 1:
				raise MalformedCollectionError(
						"No YAML document found in file %s" % bltname)
			base = base[0]
			for basefile in base:
				self.basefilenames.append(join(self.backend_root,coll,basefile["filename"]))
				if basefile["type"] == "module":
					for mod in basefile["modules"]:
						module = BaseModule(mod,basefile)
						for id in mod["ids"]:
							if id in self.getbase:
								raise NonUniqueClassIdentifier
							self.getbase[id] = module

	def write_output(self):
		out_path = join(self.backend_root,"output")

		#clear output and copy files
		rmtree(out_path,True)

		makedirs(out_path)
		bolts_fid = open(join(out_path,"BOLTS.scad"),"w")

		makedirs(join(out_path,"tables"))

		makedirs(join(out_path,"common"))
		for filename in listdir(join(self.backend_root,"common")):
			copy(join(self.backend_root,"common",filename),join(out_path,"common",filename))
			bolts_fid.write("include <common/%s>\n" % filename)

		makedirs(join(out_path,"base"))
		for filename in self.basefilenames:
			copy(filename,join(out_path,"base"))
			bolts_fid.write("include <base/%s>\n" % basename(filename))


		#write tables
		for collection in self.repo.collections:
			for cl in collection.classes:
				table_path = join("tables","%s_table.scad" % cl.name)
				table_filename = join(out_path,table_path)
				fid = open(table_filename,"w")

				for table,i in zip(cl.parameters.tables,range(len(cl.parameters.tables))):
					cols = table.columns
					fid.write("/* Generated by BOLTS, do not modify */\n")
					fid.write("/* Copyright by: %s */\n" % ",".join(collection.authors))
					fid.write("/* %s */\n" % collection.license)

					data = table.data

					fid.write("function %s_table_%d(key) = \n" % (cl.name,i))
					for k,values in data.iteritems():
						data = ["None" if v is None else v for v in values]
						fid.write('key == "%s" ? %s : \n' % (k,str(data).replace("'",'"')))
					fid.write('"Error";\n\n')
				fid.close()

				bolts_fid.write("include <%s>\n" % table_path)
		bolts_fid.write("\n\n")

		#write stubs
		for collection in self.repo.collections:
			for cl in collection.classes:
				#collect textual parameter representations
				args = {}
				if not cl.standard is None:
					args['standard'] = '"%s"' % cl.name
				params = cl.parameters
				for p in params.free:
					args[p] = p
				args.update(params.literal)
				for table,i in zip(params.tables,range(len(params.tables))):
					for p,j in zip(table.columns,range(len(table.columns))):
						args[p] = 'measures_%d[%d]' % (i,j)

				bolts_fid.write('module %s(%s){\n' % (cl.name, ', '.join(cl.parameters.free)))
	
				for table,i in zip(cl.parameters.tables,range(len(cl.parameters.tables))):
					bolts_fid.write('\tmeasures_%d = %s_table_%d(%s);\n' % (i,cl.name,i,table.index))
					bolts_fid.write('\tif(measures_%d == "Error"){\n' % i)
					bolts_fid.write('\t\techo("TableLookUpError in %s, table %d");\n\t}\n' % (cl.name,i))

				bolts_fid.write('\tif(BOLTS_MODE == "bom"){\n')

				#write part name output for bom
				argc = 0
				bolts_fid.write('\t\techo(str(" "')
				for token in cl.naming.template.split():
					if token[0] == "%":
						bolts_fid.write(",")
						bolts_fid.write(args[cl.naming.substitute[argc]])
						bolts_fid.write('," "')
						argc += 1
					else:
						bolts_fid.write(',"%s"' % token)
						bolts_fid.write('," "')
				bolts_fid.write("));\n")
				#To avoid problems with missing top level object
				bolts_fid.write("\t\tcube();\n")

				bolts_fid.write("\t} else {\n")

				#module call
				base = self.getbase[cl.id]
				bolts_fid.write('\t\t%s(%s);\n\t}\n}\n\n' % 
						(base.name,',\n\t\t\t'.join(args[arg] for arg in base.arguments)))
		bolts_fid.close()

